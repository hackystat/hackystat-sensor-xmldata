//
//package org.hackystat.sensor.xmldata;
//
//import java.io.File;
//import java.io.IOException;
//import java.util.ArrayList;
//import java.util.Date;
//import java.util.List;
//import java.util.Observable;
//import java.util.Observer;
//import java.util.StringTokenizer;
//
//import org.apache.tools.ant.BuildException;
//import org.apache.tools.ant.DirectoryScanner;
//import org.apache.tools.ant.Task;
//import org.apache.tools.ant.types.FileSet;
//import org.hackystat.core.kernel.admin.SensorProperties;
//import org.hackystat.sensor.xmldata.command.CommandEvent;
//import org.hackystat.sensor.xmldata.command.CommandListener;
//import org.hackystat.sensor.xmldata.option.OptionEvent;
//import org.hackystat.sensor.xmldata.option.OptionListener;
//
///**
// * Implements an Ant task that parses the XML files generated by any tool. Ant Task and sends the
// * Sensor Data to a Hackystat server.
// * 
// * @author Aaron A. Kagawa, Austen Ito
// * @version $Id$
// */
//public class XmlDataSensor extends Task implements CommandListener, OptionListener, Observer {
//  /** The list of all XML file sets generated by the XmlDataSensor task. */
//  private ArrayList filesets;
//  /** Whether the user has enabled this sensor in their properties file. */
//  private boolean isEnabled = false;
//  /** Parses the xml output files */
//  private XmlDataOutputParser outputParser = new XmlDataOutputParser();
//  /** The list of arguments received from ant */
//  private List arguments = new ArrayList();
//  /** The <code>SensorProperties</code> object associated with this class */
//  private SensorProperties sensorProps;
//  /** The start time of the ant sensor used to printout time the sensor took to run. */ 
//  private long startTime;
//
//  /** Initialize a new instance of a XmlDataSensor. */
//  public XmlDataSensor() {
//    this.sensorProps = new SensorProperties("XmlData-Ant");
//    this.filesets = new ArrayList();
//    this.isEnabled = this.sensorProps.isSensorEnabled();
//    XmlDataController.addCommandListeners(this);
//    XmlDataController.addOptionListeners(this);
//  }
//
//  /**
//   * Constructor used to unit test this sensor. Constructors notifies the XmlDataOutputParser that
//   * unit testing is being done and that each shell needs to use the testdataset key.
//   * 
//   * @param isTesting true if running unit tests, false if not.
//   */
//  public XmlDataSensor(boolean isTesting) {
//    this.sensorProps = new SensorProperties("XmlData-Ant");
//    this.filesets = new ArrayList();
//    this.isEnabled = this.sensorProps.isSensorEnabled();
//    this.outputParser.setTesting(isTesting);
//  }
//
//  /**
//   * Initialize a new instance of a XmlDataSensor, passing the host and directory key in explicitly.
//   * This supports testing. Note that when this constructor is called, offline data recovery by the
//   * sensor is disabled.
//   * 
//   * @param host The hackystat host URL.
//   * @param dirKey The user's 12 character key.
//   */
//  public XmlDataSensor(String host, String dirKey) {
//    this.filesets = new ArrayList();
//    XmlDataController.addCommandListeners(this);
//    XmlDataController.addOptionListeners(this);
//  }
//
//  /**
//   * Executes the XmlDataSensor. This method is invoked automatically by Ant.
//   * 
//   * @throws BuildException If there is an error.
//   */
//  public void execute() throws BuildException {
//    // Return without sending data if the sensor is disabled.
//    if (!this.isEnabled) {
//      System.out.println("XmlDataSensor disabled; no data sent.");
//      return;
//    }
//    this.startTime = new Date().getTime();
//    this.getFileNames();
//    try {
//      XmlDataController controller = new XmlDataController(this, this.arguments);
//      controller.processCommands();
//      if (XmlDataController.isVerbose()) {
//        System.out.println("Sensor enabled: " + this.isEnabled);
//      }
//      controller.execute();
//    }
//    catch (IOException e) {
//      System.out.println("A fatal error has occurred.  Please contact "
//          + "your hackystat administrator.");
//    }
//  }
//
//  /**
//   * Add a file set which contains the XmlSensorData file to be processed. 
//   * Invoked automatically by Ant.
//   * 
//   * @param fs The new file set of xml results.
//   */
//  public void addFileSet(FileSet fs) {
//    this.filesets.add(fs);
//  }
//
//  /** Get all of the files in the file set. */
//  private void getFileNames() {
//    final int size = filesets.size();
//    this.arguments.add("-file");
//    for (int i = 0; i < size; i++) {
//      FileSet fs = (FileSet) filesets.get(i);
//      DirectoryScanner ds = fs.getDirectoryScanner(getProject());
//      ds.scan();
//      String[] f = ds.getIncludedFiles();
//
//      for (int j = 0; j < f.length; j++) {
//        String pathname = f[j];
//        File file = new File(ds.getBasedir(), pathname);
//        file = getProject().resolveFile(file.getPath());
//        this.arguments.add(file.getPath());
//      }
//    }
//  }
//
//  /**
//   * Main method used to test out simple stuff.
//   * 
//   * @param args Ignored for now.
//   */
//  public static void main(String args[]) {
//    XmlDataSensor sensor = new XmlDataSensor();
//    sensor.execute();
//  }
//
//  /**
//   * Sets the sdt name. The sdt name is only used when a sdt attribute is not present.
//   * 
//   * @param sdtName the sdt name.
//   */
//  public void setSdt(String sdtName) {
//    this.arguments.add("-sdt");
//    this.arguments.add(sdtName);
//  }
//
//  /**
//   * Sets the runtime string. A runtime string is created only if it is not present.
//   * 
//   * @param runtimeString the runtime string.
//   */
//  public void setCreateRunTime(String runtimeString) {
//    this.arguments.add("-createRunTime");
//    this.arguments.add(runtimeString);
//  }
//
//  /**
//   * Sets the name map.
//   * 
//   * @param nameMap the name map string.
//   */
//  public void setNameMap(String nameMap) {
//    StringTokenizer tokenizer = new StringTokenizer(nameMap, ",");
//    while (tokenizer.hasMoreTokens()) {
//      StringTokenizer mapTokenizer = new StringTokenizer((String) tokenizer.nextToken(), "=");
//      if (mapTokenizer.countTokens() % 2 != 0) {
//        XmlDataController
//            .notifyCommandListeners(new CommandEvent("Invalid nameMap specification.", false,
//                                                     true));
//        System.exit(1);
//      }
//      while (mapTokenizer.hasMoreTokens()) {
//        this.arguments.add("-nameMap");
//        String oldValue = (String) mapTokenizer.nextToken();
//        String newValue = (String) mapTokenizer.nextToken();
//        this.arguments.add(oldValue.trim());
//        this.arguments.add(newValue.trim());
//      }
//    }
//  }
//
//  /**
//   * Enables the verbose mode if the String accepted is 'true', 'on', or 'yes'. Verbose mode is off
//   * by default.
//   * 
//   * @param verboseString the string accepted.
//   */
//  public void setVerbose(String verboseString) {
//    this.arguments.add("-verbose");
//    this.arguments.add(verboseString);
//  }
//
//  /**
//   * Is triggered when a <code>CommandEvent</code> is fired.
//   * 
//   * @param e the <code>CommandEvent</code> fired from the execution of a <code>Command</code>.
//   */
//  public void commandPerformed(CommandEvent e) {
//    if (!e.isFatal()) {
//      long elapsedTime = (new Date().getTime() - this.startTime) / 1000;
//      System.out.println("Hackystat data from " + e.getEntriesSent() + " entries sent to "
//          + this.sensorProps.getHackystatHost() + " (" + elapsedTime + " secs.)");
//    }
//    else {
//      if (!"".equals(e.getMessage())) { // used so that a two newlines are not printed.
//        System.out.println(e.getMessage());
//      }
//      if (e.isFatal()) {
//        System.exit(1);
//      }
//    }
//  }
//
//  /**
//   * Is triggered when an option is set.
//   * 
//   * @param e the <code>OptionEvent</code> fired from the setting of an <code>Option</code>.
//   */
//  public void setOptionPerformed(OptionEvent e) {
//    if (!e.isSet()) {
//      System.out.println(e.getMessage());
//    }
//  }
//
//  /**
//   * Informs the user's of a change in the system.
//   * 
//   * @param observable the object that has been changed.
//   * @param message the message that describes the change.
//   */
//  public void update(Observable observable, Object message) {
//    if (XmlDataController.isVerbose()) {
//      System.out.println(message);
//    }
//  }
//}